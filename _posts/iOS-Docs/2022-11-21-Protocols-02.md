---
title: "Protocols 02(작성중...)"
excerpt: "iOS 문서 훑어보기"
  
toc: true
toc_sticky: true

categories:
  - iOS-docs
tags:
  - [iOS-docs, swift]
  
permalink: /ios-docs/protocols-02

---
Swift 문서는 [여기](https://docs.swift.org/swift-book/LanguageGuide/Protocols.html)!

## Adding Protocol Conformance with an Extension

프로토콜을 채택하는 것은 extension에서 할 수도 있다. extension에서 프로토콜을 준수하면 인스턴스에서 사용 가능.

```swift
extension Dice: TextRepresentable {
    var textualDescription: String {
        return "A \(sides)-sided dice"
    }
}
```

### Conditionally Conforming to a Protocol

- Generic type은 타입의 Generic 파라메터가 프로토콜을 준수하는 경우와 같은 특정 조건에서만 프로토콜의 요구사항을 만족시킬 수 있음
- where 절을 추가해 프로토콜의 제약 조건을 작성한다

```swift
extension Array: TextRepresentable where Element: TextRepresentable {
    var textualDescription: String {
        let itemsAsText = self.map { $0.textualDescription }
        return "[" + itemsAsText.joined(separator: ", ") + "]"
    }
}
let myDice = [d6, d12]
print(myDice.textualDescription)
// Prints "[A 6-sided dice, A 12-sided dice]"
```

- 위 코드에서는 Array의 Element가 TextRepresentable을 준수할 때 Array도 TextRepresentable 프로토콜을 준수하도록 한다.

### Declaring Protocol Adoption with an Extension

```swift
struct Hamster {
    var name: String
    var textualDescription: String {
        return "A hamster named \(name)"
    }
}
extension Hamster: TextRepresentable {}
```

- 어떤 유형이 프로토콜을 준수하고 있지만 아직 프로토콜을 채택하지 않은 경우 `extension Hamster: TextRepresentable {}` 처럼 빈 extension을 사용해 프로토콜을 채택할 수 있다.

## Adopting a Protocol Using a Synthesized Implementation

- Swift는 Equatable, Hashable, Comparable과 같은 프로토콜을 제공한다. 따로 코드를 구현하지 않아도 해당 프로토콜들을 채택하면 기능을 사용할 수 있다.
- Equatable: 채택시 == 또는 !=으로 비교 가능
   - Equatable 프로토콜을 준수하는 stored property만 있는 struct
   - Equatable 프로토콜을 준수하는 associated type만 있는  Enum
   - associated type이 없는 Enum
- Hashable: 채택시 hash(into:) 구현할 필요 없음
   - Hashable 프로토콜을 준수하는 Stored property만 있는 struct
   - Hashable 프로토콜을 준수하는 associated type만 있는 Enum
   - associated type이 없는 Enum
- Comparable: <=, >, >=
   - raw vlaue가 없는 enum
   - associated type이 있는 경우에는 그 type이 Comparable을 준수해얗 ㅏㅁ
```swift
struct Vector3D: Equatable {
    var x = 0.0, y = 0.0, z = 0.0
    // Equatable 프로토콜을 준수하는 stored property만 있는 struct
}

let twoThreeFour = Vector3D(x: 2.0, y: 3.0, z: 4.0)
let anotherTwoThreeFour = Vector3D(x: 2.0, y: 3.0, z: 4.0)
if twoThreeFour == anotherTwoThreeFour {
    print("These two vectors are also equivalent.")
}
// Prints "These two vectors are also equivalent."

enum SkillLevel: Comparable {
    case beginner
    case intermediate
    case expert(stars: Int)
}
var levels = [SkillLevel.intermediate, SkillLevel.beginner,
              SkillLevel.expert(stars: 5), SkillLevel.expert(stars: 3)]
for level in levels.sorted() {
    print(level)
}
// Prints "beginner"
// Prints "intermediate"
// Prints "expert(stars: 3)"
// Prints "expert(stars: 5)"
```

## Collections of Protocol Types
```swift
let things: [TextRepresentable] = [game, d12, simonTheHamster]

for thing in things {
    print(thing.textualDescription)
}
// A game of Snakes and Ladders with 25 squares
// A 12-sided dice
// A hamster named Simon
```
- Array와 같은 Collection에서 Type의 유형을 protocol 로 지정할 수 있다.
   - protocol을 준수하는 어떤 타입이든 저장이 가능하고, 프로토콜에서 정의를 요구하는 값들을 사용할 수 있다.

## Protocol Inheritance

```swift
protocol InheritingProtocol: SomeProtocol, AnotherProtocol {
    // protocol definition goes here
}
```

- 프로토콜은 프로토콜을 상속할 수 있다. Class의 상속과 동일한 폼으로 작성하면 되고 쉼표를 넣어 상속받을 프로토콜을 여러개 나열할 수 있다.
   - InheritingProtocol을 채택하면 해당 프로토콜이 상속받은 SomeProtocol과 AnotherProtocol까지 모두 준수할 수 있도록 코드를 구현해야 한다.

## Class-Only Protocols
```swift
protocol SomeClassOnlyProtocol: AnyObject, SomeInheritedProtocol {
    // class-only protocol definition goes here
}
```

- Class만 채택할 수 있는 프로토콜을 생성할 수도 있다. **AnyObject**를 프로토콜의 상속 목록에 추가한다.

> Use a class-only protocol when the behavior defined by that protocol’s requirements assumes or requires that a conforming type has reference semantics rather than value semantics. For more about reference and value semantics, see [Structures and Enumerations Are Value Types](https://docs.swift.org/swift-book/LanguageGuide/ClassesAndStructures.html#ID88) and [Classes Are Reference Types](https://docs.swift.org/swift-book/LanguageGuide/ClassesAndStructures.html#ID89).

## Protocol Composition
## Checking for Protocol Conformance
## Optional Protocol Requirements
## Protocol Extensions
